<<: !include platform.yaml

# initialize and define mitsurunner
esphome:
  name: mitsurunner
  platform: $platform_type
  board: $board_type
  on_boot: 
  - switch.turn_on: gpio_relay
  - script.execute: schedule_forced_defrosting
  - script.execute: enter_Reset
  includes:
    - constants.h
    - state.h

# global variables and their initial values
globals:
  - id: G_max_heating_time_passed
    type: bool
    initial_value: 'false'
  - id: G_state #variable containing state machine state
    type: int
    initial_value: 'ST_RESET'
  - id: G_state_time_passed #for state machine timeouts etc.
    type: bool
    initial_value: 'false'
  - id: G_state_timer #for state machine timeouts etc.
    type: int
    initial_value: '0'

# global constants
  - id: G_TOPIC_STATE
    type: const char*
    initial_value: $topic_state
  - id: G_TOPIC_DELTA
    type: const char*
    initial_value: $topic_delta

# dallas DS28B20 sensor
# device measures temperature in 10 seconds interval
dallas:
  - pin: $dallas_pin
    update_interval: 10s
    id: dallas1

# switch component to control defrost prevention relay
# if switch on --> Relay actively driven
# if switch off --> Relay in default state
switch:
  - platform: gpio
    pin: $relay_pin
    name: "Defrost prevention control"
    id: gpio_relay

# Dallas DS18B20 temperature sensor details. 
# you need to check IDs of temperature sensors by starting this SW and checking those from logs printing to terminal. 
# After checked, copy IDs to platform.yaml file and heat another sensor. Check which sensor it were and use it for the appropriate topic
sensor:
  - platform: dallas
    address: $dallas_address_heat_exchanger_temp # Please remember to define this on platform.yaml
    name: "outdoor unit heat exchanger temperature"
    id: heat_exchanger_temp
    accuracy_decimals: 1
    state_topic: $topic_heatexchanger
    filters:    
      - filter_out: nan
  - platform: dallas
    address: $dallas_address_outdoor_temp # Please remember to define this on platform.yaml
    name: "outdoor temperature"
    id: outdoor_temp
    accuracy_decimals: 1
    state_topic: $topic_outdoor
    filters:
      - filter_out: nan

# additional sensors can be added by defining new sensors - uncomment example below:
# e.g. for having another sensors to measure outdoor temperature from different place. (not used by logic)
  # - platform: dallas
  #   address: $dallas_address_test
  #   name: "test_temperature"
  #   id: test_temperature
  #   accuracy_decimals: 1
  #   state_topic: $topic_test
  #   filters:
  #     - filter_out: nan

# State machine to trigger defrosting when needed
  - platform: template
    id: state_machine
    name: "Defrost state machine"
    update_interval: 30s
# This C++ code checks if all requirements are fullfilled to trigger defrosting and triggers it then.
    lambda: !lambda |-
        float temperature_delta = (id(outdoor_temp).state - id(heat_exchanger_temp).state);

        id(mqtt_client).publish(id(G_TOPIC_DELTA), to_string(temperature_delta));
        id(mqtt_client).publish(id(G_TOPIC_STATE), to_string(id(G_state)));

        switch(id(G_state)) {

            // This state is executed only in reset
            case ST_RESET:
                // Wait first that sensors has read some values.
                if (G_state_time_passed) {
                    // If defrosting is going on
                    if (temperature_delta < 0.0) {
                        id(enter_DefrostingStarted).execute();
                    }
                    else {
                        id(enter_Idle).execute();
                    }                  
                }
                break;

            case ST_IDLE:
                // If maximum heating time exceeded, start defrosting immediately
                if (id(G_max_heating_time_passed)) {
                    id(enter_StartDefrosting).execute();
                }
                // Wait for the temperature delta threshold to be exceeded.
                else if (temperature_delta >= TEMPERATURE_DELTA_TO_DEFROST) {
                    id(enter_TempExceeded).execute();
                }
                break;

            case ST_TEMP_EXCEEDED:
                // If the time threshold or the upper temperature limit is exceeded, start defrosting
                if (id(G_state_time_passed) || id(G_max_heating_time_passed) ||
                        (temperature_delta >= TEMPERATURE_DELTA_TO_FORCE_DEFROST)) {
                    id(enter_StartDefrosting).execute();
                }
                else if (temperature_delta < TEMPERATURE_DELTA_TO_DEFROST) {
                    id(enter_Idle).execute();
                }
                break;

            case ST_START_DEFROSTING:
                // Check that defrosting is really started.
                if (temperature_delta < 0.0) {
                    id(enter_DefrostingStarted).execute();
                }
                // Timeout to go back to the idle state, if defrosting has not been started.
                else if (id(G_state_time_passed)) {
                    id(enter_Idle).execute();
                }
                break;

            case ST_DEFROSTING_STARTED:
                // Keep the relay off for a while.
                if (id(G_state_time_passed)) {
                    id(enter_HeatingMinTime).execute();
                }
                break;

            case ST_HEATING_MIN_TIME:
                // Max time should never pass in this state, but checked here to be sure.
                if (id(G_max_heating_time_passed)) {
                    id(enter_StartDefrosting).execute();
                } 
                // If the upper temperature limit is exceeded, start defrosting directly.
                else if (temperature_delta >= TEMPERATURE_DELTA_TO_FORCE_DEFROST) {
                    id(enter_StartDefrosting).execute();
                }
                // Do not react normal temperature delta threshold before min heating time has been passed.
                else if (id(G_state_time_passed)) {
                    id(enter_Idle).execute();
                }
                break;

            // Should never end up in here
            default:
                id(enter_Idle).execute();
                break;
        }
        return temperature_delta;

script:

# -------- State machine state entrance scripts --------


############## ST_RESET ###############
  - id: enter_Reset
    mode: single
    then:
    - switch.turn_off: gpio_relay
    - lambda: !lambda |-
        id(G_state) = ST_RESET;
        id(G_state_timer) = RESET_SENSOR_DELAY_SEC * 1000;
    - script.execute: start_state_timer

############### ST_IDLE ###############
  - id: enter_Idle
    mode: single
    then:
    - switch.turn_on: gpio_relay
    - lambda: !lambda |-
        id(G_state) = ST_IDLE;

########## ST_TEMP_EXCEEDED ###########
  - id: enter_TempExceeded
    mode: single
    then:
    - switch.turn_on: gpio_relay
    - lambda: !lambda |-
        id(G_state) = ST_TEMP_EXCEEDED;
        id(G_state_timer) = TEMPERATURE_DELTA_EXCESS_TIME * 60000;
    - script.execute: start_state_timer

######### ST_START_DEFROSTING #########
  - id: enter_StartDefrosting
    mode: single
    then:
    - switch.turn_off: gpio_relay
    - lambda: !lambda |-
        id(G_state) = ST_START_DEFROSTING;
        id(G_state_timer) =  DEFROST_TIMEOUT * 60000;
    - script.execute: start_state_timer
    - script.execute: schedule_forced_defrosting

######## ST_DEFROSTING_STARTED ########
  - id: enter_DefrostingStarted
    mode: single
    then:
    - switch.turn_off: gpio_relay
    - lambda: !lambda |-
        id(G_state) = ST_DEFROSTING_STARTED;
        id(G_state_timer) =  RELAY_OFF_TIME * 60000;
    - script.execute: start_state_timer

######### ST_HEATING_MIN_TIME #########
  - id: enter_HeatingMinTime
    mode: single
    then:
    - switch.turn_on: gpio_relay
    - lambda: !lambda |-
        id(G_state) = ST_HEATING_MIN_TIME;
        id(G_state_timer) =  (MIN_HEATING_TIME - RELAY_OFF_TIME) * 60000;
    - script.execute: start_state_timer

# ------------------------------------------------------

# Script for timer used for state machine timeouts etc.
  - id: start_state_timer
    mode: restart
    then:
    - lambda: !lambda |-
        id(G_state_time_passed) = false;
    - delay: !lambda "return id(G_state_timer);"
    - lambda: !lambda |-
        id(G_state_time_passed) = true;
    
# Script for forced defrosting
# Forced defrosting prevents oil to accumulate to some places in device, 
# which may cause compressor not to get oiled when running.
  - id: schedule_forced_defrosting
    mode: restart #timer will be restarted from the beginning allways when called --> starts always again           
    then:
    - lambda: !lambda |-
        id(G_max_heating_time_passed) = false;
    - delay: !lambda "return MAX_HEATING_TIME * 60000;"
    - lambda: !lambda |-
        id(G_max_heating_time_passed) = true;
