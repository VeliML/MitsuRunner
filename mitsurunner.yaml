<<: !include platform.yaml

# initialize and define mitsurunner
esphome:
  name: mitsurunner
  platform: $platform_type
  board: $board_type
  on_boot: 
  - switch.turn_on: gpio_relay
  - script.execute: schedule_forced_defrosting
  includes:
    - constants.h
    - state.h

# global variables and their initial values
globals:
  - id: G_min_heating_time_passed #variable controlling minimum heating time after defrosting
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: G_excess_min_time_passed #variable preventing defrosting until excess time has been passed
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: G_state
    type: int
    restore_value: no
    initial_value: 'ST_RESET'
  - id: G_state_time_passed
    type: bool
    restore_value: no
    initial_value: 'false'


# dallas DS28B20 sensor
# device measures temperature in 10 seconds interval
dallas:
  - pin: $dallas_pin
    update_interval: 10s
    id: dallas1

# switch component to control defrost prevention relay
# if switch on --> Relay actively driven
# if switch off --> Relay in default state
switch:
  - platform: gpio
    pin: $relay_pin
    name: "Defrost prevention control"
    id: gpio_relay

# Dallas DS18B20 temperature sensor details. 
# you need to check IDs of temperature sensors by starting this SW and checking those from logs printing to terminal. 
# After checked, copy IDs to platform.yaml file and heat another sensor. Check which sensor it were and use it for the appropriate topic
sensor:
  - platform: dallas
    address: $dallas_address_heat_exchanger_temp # Please remember to define this on platform.yaml
    name: "outdoor unit heat exchanger temperature"
    id: heat_exchanger_temp
    accuracy_decimals: 1
    state_topic: $topic_heatexchanger
    filters:    
      - filter_out: nan
  - platform: dallas
    address: $dallas_address_outdoor_temp # Please remember to define this on platform.yaml
    name: "outdoor temperature"
    id: outdoor_temp
    accuracy_decimals: 1
    state_topic: $topic_outdoor
    filters:
      - filter_out: nan

# additional sensors can be added by defining new sensors - uncomment example below:
# e.g. for having another sensors to measure outdoor temperature from different place. (not used by logic)
  # - platform: dallas
  #   address: $dallas_address_test
  #   name: "test_temperature"
  #   id: test_temperature
  #   accuracy_decimals: 1
  #   state_topic: $topic_test
  #   filters:
  #     - filter_out: nan

# Logic to trigger defrosting when needed
  - platform: template
    id: is_defrosting_needed
    name: "Check if defrosting is needed"
    update_interval: 30s
# this C++ code checks if all requirements are fullfilled to trigger defrosting and triggers it then.
    lambda: !lambda |-
        float temperature_delta = (id(outdoor_temp).state - id(heat_exchanger_temp).state);
        bool reset_min_time_of_temperature_delta = false;


        // if you want to get MQTT logs from temperature delta all the time, define TOPIC_TEMP_DELTA in constants.h file
        #ifdef TOPIC_TEMP_DELTA_MESSAGES
        id(mqtt_client).publish(TOPIC_TEMP_DELTA, to_string(temperature_delta));
        #endif

        id(mqtt_client).publish(TOPIC_STATE, to_string(id(G_state)));

        switch(id(G_state)) {

            // This state is executed only in reset
            case ST_RESET:
                // If defrosting is going on
                if (temperature_delta < 0.0) {
                    id(EnterDefrostingStarted).execute();
                }
                // If defrosting is not going on
                else {
                    id(schedule_forced_defrosting).execute();
                    id(EnterIdle).execute();
                }
                break;

            case ST_IDLE:
                if (temperature_delta >= TEMPERATURE_DELTA_TO_DEFROST) {
                    id(EnterTempExceeded).execute();
                }
                break;

            case ST_TEMP_EXCEEDED:
                if (id(G_state_time_passed) || (temperature_delta >= TEMPERATURE_DELTA_TO_FORCE_DEFROST)) {
                    id(EnterStartDefrosting).execute();
                }
                else if (temperature_delta < TEMPERATURE_DELTA_TO_DEFROST) {
                    id(EnterIdle).execute();
                }
                break;

            case ST_START_DEFROSTING:
                if (temperature_delta < 0.0) {
                    id(EnterDefrostingStarted).execute();
                }
                // Timeout to go back to the idle state, if defrosting has not been started
                else if (id(G_state_time_passed)) {
                    id(EnterIdle).execute();
                }
                break;

            case ST_DEFROSTING_STARTED:
                if (id(G_state_time_passed)) {
                    id(EnterHeatingMinTime).execute();
                }
                break;

            case ST_HEATING_MIN_TIME:
                if (id(G_state_time_passed)) {
                    id(EnterIdle).execute();
                }
                break;
        }
        return temperature_delta;


script:

# -------- State machine state entrance scripts --------

  - id: EnterIdle
    mode: single
    then:
    #Stop other state scripts
    - script.stop: EnterTempExceeded
    - script.stop: EnterStartDefrosting
    - script.stop: EnterDefrostingStarted
    - script.stop: EnterHeatingMinTime
    - switch.turn_on: gpio_relay

    - lambda: !lambda |-
        id(G_state) = ST_IDLE;
        id(G_state_time_passed) = false;


  - id: EnterTempExceeded
    mode: single
    then:
    #Stop other state scripts
    - script.stop: EnterIdle
    - script.stop: EnterStartDefrosting
    - script.stop: EnterDefrostingStarted
    - script.stop: EnterHeatingMinTime
    - switch.turn_on: gpio_relay

    - lambda: !lambda |-
        id(G_state) = ST_TEMP_EXCEEDED;
        id(G_state_time_passed) = false;

    - delay: 5min
    - lambda: !lambda |-
        id(G_state_time_passed) = true;


  - id: EnterStartDefrosting
    mode: single
    then:
    #Stop other state scripts
    - script.stop: EnterIdle
    - script.stop: EnterTempExceeded
    - script.stop: EnterDefrostingStarted
    - script.stop: EnterHeatingMinTime
    - switch.turn_off: gpio_relay

    - lambda: !lambda |-
        id(G_state) = ST_START_DEFROSTING;
        id(G_state_time_passed) = false;

    - delay: 10min
    - lambda: !lambda |-
        id(G_state_time_passed) = true;


  - id: EnterDefrostingStarted
    mode: single
    then:
    #Stop other state scripts
    - script.stop: EnterIdle
    - script.stop: EnterTempExceeded
    - script.stop: EnterStartDefrosting
    - script.stop: EnterHeatingMinTime
    - switch.turn_off: gpio_relay

    - script.stop: schedule_forced_defrosting
    - script.execute: schedule_forced_defrosting

    - lambda: !lambda |-
        id(G_state) = ST_DEFROSTING_STARTED;
        id(G_state_time_passed) = false;

    - delay: 30min
    - lambda: !lambda |-
        id(G_state_time_passed) = true;


  - id: EnterHeatingMinTime
    mode: single
    then:
    #Stop other state scripts
    - script.stop: EnterIdle
    - script.stop: EnterTempExceeded
    - script.stop: EnterStartDefrosting
    - script.stop: EnterDefrostingStarted
    - switch.turn_on: gpio_relay
    - lambda: !lambda |-
        id(G_state) = ST_HEATING_MIN_TIME;
        id(G_state_time_passed) = false;

    - delay: 20min
    - lambda: !lambda |-
        id(G_state_time_passed) = true;

# ------------------------------------------------------
    
# scipt for forced defrosting
# forced defrosting prevents oil to accumulate to some places in device, preventing compressor to get oiled during it's running 
  - id: schedule_forced_defrosting
    mode: restart #timer will be restarted from the beginning allways when called --> starts always again           
    then:
    - delay: 150min
    - script.execute: EnterStartDefrosting

