<<: !include platform.yaml

# initialize and define mitsurunner
esphome:
  name: mitsurunner
  platform: $platform_type
  board: $board_type
  on_boot: 
  - switch.turn_on: gpio_relay
  - script.execute: schedule_forced_defrosting
#  - script.execute: start_min_heting_time_timer
  includes:
    - constants.h

# global varialbes and their initial values
globals:
  - id: G_min_heating_time_passed #variable controlling minimum heating time after defrosting
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: G_excess_min_time_passed #variable preventing defrosting untill excess time has been passed
    type: bool
    restore_value: no
    initial_value: 'false'

# dallas DS28B20 sensor
# device measures temperature in 10 seconds interval
dallas:
  - pin: $dallas_pin
    update_interval: 10s
    id: dallas1

# switch component to control defrost prevention relay
# if switch on --> Relay actively driven
# if switch off --> Relay in default state
switch:
  - platform: gpio
    pin: $relay_pin
    name: "Defrost prevention control"
    id: gpio_relay

# Dallas DS18B20 temperature sensor details. 
# you need to check IDs of temperature sensors by starting this SW and checking those from logs printing to termina. 
# After checked, copy IDs to platform.yaml file and heat another sensor. Check which sensor it were and use it for the appropriate topic
sensor:
  - platform: dallas
    address: $dallas_address_heat_exhanger_temp # Please remember to define this on platform.yaml
    name: "outdoor unit heat exhanger temperature"
    id: heat_exhanger_temp
    accuracy_decimals: 1
    state_topic: $topic_heatexhanger
    filters:    
      - filter_out: nan
  - platform: dallas
    address: $dallas_address_outdoor_temp # Please remember to define this on platform.yaml
    name: "outdoor temperature"
    id: outdoor_temp
    accuracy_decimals: 1
    state_topic: $topic_outdoor
    filters:
      - filter_out: nan

# additional sensors can be added by defining new sensors - uncomment example below:
# e.g. for having another sensors to measure outdoor temperature from different place. (not used by logic)
  # - platform: dallas
  #   address: $dallas_address_test
  #   name: "test_temperature"
  #   id: test_temperature
  #   accuracy_decimals: 1
  #   state_topic: $topic_test
  #   filters:
  #     - filter_out: nan

# Logic to trigger defrosting when needed
  - platform: template
    id: is_defrosting_needed
    name: "Check if defrosting is needed"
    update_interval: 30s
# this C++ code checks if all requirements are fullfilled to trigger defrosting and triggers it then.
    lambda: !lambda |-
        float temperature_delta = (id(outdoor_temp).state - id(heat_exhanger_temp).state);
        bool reset_min_time_of_temperature_delta = false;

        // if temperature delta is over treshold and minimum heating time has passed
        if ( temperature_delta >= TEMPERATURE_DELTA_TO_DEFROST && id(G_min_heating_time_passed) == true) {
            // if temperature has been long enough over treshold or force defrost temperature is exceeded
            if ( id(G_excess_min_time_passed) == true || temperature_delta >= TEMPERATURE_DELTA_TO_FORCE_DEFROST) {
                // activate defrosting
                id(trigger_defrosting).execute();
                reset_min_time_of_temperature_delta = true;
                }
            // if excess timer were not yet passed, do nothing
            else if ( id(start_excess_min_time_timer).is_running() ) {
                }
            // excess min itme were not on, but other defrosting requirements were fullfilled to start it
            else  
                { 
                id(start_excess_min_time_timer).execute();
                }
            }            
        else {        
            // if during the excess timer, the temperature returns back below treshold, then cancel the timer
            reset_min_time_of_temperature_delta = true;       
            }
        
        if ( reset_min_time_of_temperature_delta ) {
            id(G_excess_min_time_passed) = false;
            
            // timer is needed to be stopped only if it is running
            if ( id(start_excess_min_time_timer).is_running() ) {
                id(start_excess_min_time_timer).stop();  
                }
            id(mqtt_client).publish(TOPIC_IS_EXCESS_MIN_TIME_PASSED, to_string(0.0));
            }

        // if you want to get MQTT logs from temperature delta all the time, define TOPIC_TEMP_DELTA in constants.h file
        #ifdef TOPIC_TEMP_DELTA_TRACES
        id(mqtt_client).publish(TOPIC_TEMP_DELTA, to_string(temperature_delta));
        #endif

        return temperature_delta;


# defrosting script
script:
  - id: trigger_defrosting
    mode: single #will be started only if there were no ongoing defrosting already
    then:    
    - switch.turn_off: gpio_relay    
    - script.execute: start_min_heting_time_timer
    - script.execute: schedule_forced_defrosting
    - lambda: !lambda |-
        id(mqtt_client).publish(TOPIC_DEFROST_HACK_STATE, to_string(0.0));
    - delay: 30min    
    - switch.turn_on: gpio_relay
    - lambda: !lambda |-
        id(mqtt_client).publish(TOPIC_DEFROST_HACK_STATE, to_string(1.0));



# scipt implementing timer for minimum heating time
# G_min_heating_time_passed is used through this timer to prevent defrosting too quickly after previous defrosting
  - id: start_min_heting_time_timer
    mode: single #will be started only if there were no ongoing defrosting already
    then:  
    - lambda: !lambda |-
        id(G_min_heating_time_passed) = false;
        id(mqtt_client).publish(TOPIC_IS_HEATING_MIN_TIME_PASSED, to_string(0.0));
    - delay: 50min 
    - lambda: !lambda |-
        id(G_min_heating_time_passed) = true; 
        id(mqtt_client).publish(TOPIC_IS_HEATING_MIN_TIME_PASSED, to_string(1.0));
        
# script implementing timer preventing defrosting if temperature delta excess defrosting treshold limit just short time. (filters out peaks)
  - id: start_excess_min_time_timer
    mode: single #will be started only if there were no ongoing defrosting already
    then:  
    - lambda: !lambda |-
        id(G_excess_min_time_passed) = false;
        id(mqtt_client).publish(TOPIC_IS_EXCESS_MIN_TIME_PASSED, to_string(0.5));
    - delay: 5min 
    - lambda: !lambda |-
        id(G_excess_min_time_passed) = true; 
        id(mqtt_client).publish(TOPIC_IS_EXCESS_MIN_TIME_PASSED, to_string(1.0));

    
# scipt for forced defrosting
# forced defrosting prevents oil to accumulate to some places in device, preventing compressor to get oiled during it's running 
  - id: schedule_forced_defrosting
    mode: restart #timer will be restarted from the beginning allways when called --> starts always again           
    then:
    - delay: 150min
    - script.execute: trigger_defrosting
